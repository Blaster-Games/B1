// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_AuthReq;
struct C_AuthReqDefaultTypeInternal;
extern C_AuthReqDefaultTypeInternal _C_AuthReq_default_instance_;
class C_CreateRoomReq;
struct C_CreateRoomReqDefaultTypeInternal;
extern C_CreateRoomReqDefaultTypeInternal _C_CreateRoomReq_default_instance_;
class C_EndGameReq;
struct C_EndGameReqDefaultTypeInternal;
extern C_EndGameReqDefaultTypeInternal _C_EndGameReq_default_instance_;
class C_EnterLobbyReq;
struct C_EnterLobbyReqDefaultTypeInternal;
extern C_EnterLobbyReqDefaultTypeInternal _C_EnterLobbyReq_default_instance_;
class C_JoinRoomReq;
struct C_JoinRoomReqDefaultTypeInternal;
extern C_JoinRoomReqDefaultTypeInternal _C_JoinRoomReq_default_instance_;
class C_LeaveRoomReq;
struct C_LeaveRoomReqDefaultTypeInternal;
extern C_LeaveRoomReqDefaultTypeInternal _C_LeaveRoomReq_default_instance_;
class C_LobbyChat;
struct C_LobbyChatDefaultTypeInternal;
extern C_LobbyChatDefaultTypeInternal _C_LobbyChat_default_instance_;
class C_Pong;
struct C_PongDefaultTypeInternal;
extern C_PongDefaultTypeInternal _C_Pong_default_instance_;
class C_ReadyGameReq;
struct C_ReadyGameReqDefaultTypeInternal;
extern C_ReadyGameReqDefaultTypeInternal _C_ReadyGameReq_default_instance_;
class C_RoomChat;
struct C_RoomChatDefaultTypeInternal;
extern C_RoomChatDefaultTypeInternal _C_RoomChat_default_instance_;
class C_RoomListReq;
struct C_RoomListReqDefaultTypeInternal;
extern C_RoomListReqDefaultTypeInternal _C_RoomListReq_default_instance_;
class C_SelectRoomReq;
struct C_SelectRoomReqDefaultTypeInternal;
extern C_SelectRoomReqDefaultTypeInternal _C_SelectRoomReq_default_instance_;
class C_StartGameReq;
struct C_StartGameReqDefaultTypeInternal;
extern C_StartGameReqDefaultTypeInternal _C_StartGameReq_default_instance_;
class S_AuthRes;
struct S_AuthResDefaultTypeInternal;
extern S_AuthResDefaultTypeInternal _S_AuthRes_default_instance_;
class S_BroadcastChangeHost;
struct S_BroadcastChangeHostDefaultTypeInternal;
extern S_BroadcastChangeHostDefaultTypeInternal _S_BroadcastChangeHost_default_instance_;
class S_BroadcastEndGame;
struct S_BroadcastEndGameDefaultTypeInternal;
extern S_BroadcastEndGameDefaultTypeInternal _S_BroadcastEndGame_default_instance_;
class S_BroadcastJoinRoom;
struct S_BroadcastJoinRoomDefaultTypeInternal;
extern S_BroadcastJoinRoomDefaultTypeInternal _S_BroadcastJoinRoom_default_instance_;
class S_BroadcastLeaveRoom;
struct S_BroadcastLeaveRoomDefaultTypeInternal;
extern S_BroadcastLeaveRoomDefaultTypeInternal _S_BroadcastLeaveRoom_default_instance_;
class S_BroadcastLobbyChat;
struct S_BroadcastLobbyChatDefaultTypeInternal;
extern S_BroadcastLobbyChatDefaultTypeInternal _S_BroadcastLobbyChat_default_instance_;
class S_BroadcastReadyGame;
struct S_BroadcastReadyGameDefaultTypeInternal;
extern S_BroadcastReadyGameDefaultTypeInternal _S_BroadcastReadyGame_default_instance_;
class S_BroadcastRoomChat;
struct S_BroadcastRoomChatDefaultTypeInternal;
extern S_BroadcastRoomChatDefaultTypeInternal _S_BroadcastRoomChat_default_instance_;
class S_BroadcastRoomState;
struct S_BroadcastRoomStateDefaultTypeInternal;
extern S_BroadcastRoomStateDefaultTypeInternal _S_BroadcastRoomState_default_instance_;
class S_BroadcastStartGame;
struct S_BroadcastStartGameDefaultTypeInternal;
extern S_BroadcastStartGameDefaultTypeInternal _S_BroadcastStartGame_default_instance_;
class S_Connected;
struct S_ConnectedDefaultTypeInternal;
extern S_ConnectedDefaultTypeInternal _S_Connected_default_instance_;
class S_CreateRoomRes;
struct S_CreateRoomResDefaultTypeInternal;
extern S_CreateRoomResDefaultTypeInternal _S_CreateRoomRes_default_instance_;
class S_EndGameRes;
struct S_EndGameResDefaultTypeInternal;
extern S_EndGameResDefaultTypeInternal _S_EndGameRes_default_instance_;
class S_EnterLobbyRes;
struct S_EnterLobbyResDefaultTypeInternal;
extern S_EnterLobbyResDefaultTypeInternal _S_EnterLobbyRes_default_instance_;
class S_ErrorMessage;
struct S_ErrorMessageDefaultTypeInternal;
extern S_ErrorMessageDefaultTypeInternal _S_ErrorMessage_default_instance_;
class S_JoinRoomRes;
struct S_JoinRoomResDefaultTypeInternal;
extern S_JoinRoomResDefaultTypeInternal _S_JoinRoomRes_default_instance_;
class S_KickPlayer;
struct S_KickPlayerDefaultTypeInternal;
extern S_KickPlayerDefaultTypeInternal _S_KickPlayer_default_instance_;
class S_LeaveRoomRes;
struct S_LeaveRoomResDefaultTypeInternal;
extern S_LeaveRoomResDefaultTypeInternal _S_LeaveRoomRes_default_instance_;
class S_Ping;
struct S_PingDefaultTypeInternal;
extern S_PingDefaultTypeInternal _S_Ping_default_instance_;
class S_RoomListRes;
struct S_RoomListResDefaultTypeInternal;
extern S_RoomListResDefaultTypeInternal _S_RoomListRes_default_instance_;
class S_SelectRoomRes;
struct S_SelectRoomResDefaultTypeInternal;
extern S_SelectRoomResDefaultTypeInternal _S_SelectRoomRes_default_instance_;
class S_StartGameRes;
struct S_StartGameResDefaultTypeInternal;
extern S_StartGameResDefaultTypeInternal _S_StartGameRes_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_AuthReq* Arena::CreateMaybeMessage<::Protocol::C_AuthReq>(Arena*);
template<> ::Protocol::C_CreateRoomReq* Arena::CreateMaybeMessage<::Protocol::C_CreateRoomReq>(Arena*);
template<> ::Protocol::C_EndGameReq* Arena::CreateMaybeMessage<::Protocol::C_EndGameReq>(Arena*);
template<> ::Protocol::C_EnterLobbyReq* Arena::CreateMaybeMessage<::Protocol::C_EnterLobbyReq>(Arena*);
template<> ::Protocol::C_JoinRoomReq* Arena::CreateMaybeMessage<::Protocol::C_JoinRoomReq>(Arena*);
template<> ::Protocol::C_LeaveRoomReq* Arena::CreateMaybeMessage<::Protocol::C_LeaveRoomReq>(Arena*);
template<> ::Protocol::C_LobbyChat* Arena::CreateMaybeMessage<::Protocol::C_LobbyChat>(Arena*);
template<> ::Protocol::C_Pong* Arena::CreateMaybeMessage<::Protocol::C_Pong>(Arena*);
template<> ::Protocol::C_ReadyGameReq* Arena::CreateMaybeMessage<::Protocol::C_ReadyGameReq>(Arena*);
template<> ::Protocol::C_RoomChat* Arena::CreateMaybeMessage<::Protocol::C_RoomChat>(Arena*);
template<> ::Protocol::C_RoomListReq* Arena::CreateMaybeMessage<::Protocol::C_RoomListReq>(Arena*);
template<> ::Protocol::C_SelectRoomReq* Arena::CreateMaybeMessage<::Protocol::C_SelectRoomReq>(Arena*);
template<> ::Protocol::C_StartGameReq* Arena::CreateMaybeMessage<::Protocol::C_StartGameReq>(Arena*);
template<> ::Protocol::S_AuthRes* Arena::CreateMaybeMessage<::Protocol::S_AuthRes>(Arena*);
template<> ::Protocol::S_BroadcastChangeHost* Arena::CreateMaybeMessage<::Protocol::S_BroadcastChangeHost>(Arena*);
template<> ::Protocol::S_BroadcastEndGame* Arena::CreateMaybeMessage<::Protocol::S_BroadcastEndGame>(Arena*);
template<> ::Protocol::S_BroadcastJoinRoom* Arena::CreateMaybeMessage<::Protocol::S_BroadcastJoinRoom>(Arena*);
template<> ::Protocol::S_BroadcastLeaveRoom* Arena::CreateMaybeMessage<::Protocol::S_BroadcastLeaveRoom>(Arena*);
template<> ::Protocol::S_BroadcastLobbyChat* Arena::CreateMaybeMessage<::Protocol::S_BroadcastLobbyChat>(Arena*);
template<> ::Protocol::S_BroadcastReadyGame* Arena::CreateMaybeMessage<::Protocol::S_BroadcastReadyGame>(Arena*);
template<> ::Protocol::S_BroadcastRoomChat* Arena::CreateMaybeMessage<::Protocol::S_BroadcastRoomChat>(Arena*);
template<> ::Protocol::S_BroadcastRoomState* Arena::CreateMaybeMessage<::Protocol::S_BroadcastRoomState>(Arena*);
template<> ::Protocol::S_BroadcastStartGame* Arena::CreateMaybeMessage<::Protocol::S_BroadcastStartGame>(Arena*);
template<> ::Protocol::S_Connected* Arena::CreateMaybeMessage<::Protocol::S_Connected>(Arena*);
template<> ::Protocol::S_CreateRoomRes* Arena::CreateMaybeMessage<::Protocol::S_CreateRoomRes>(Arena*);
template<> ::Protocol::S_EndGameRes* Arena::CreateMaybeMessage<::Protocol::S_EndGameRes>(Arena*);
template<> ::Protocol::S_EnterLobbyRes* Arena::CreateMaybeMessage<::Protocol::S_EnterLobbyRes>(Arena*);
template<> ::Protocol::S_ErrorMessage* Arena::CreateMaybeMessage<::Protocol::S_ErrorMessage>(Arena*);
template<> ::Protocol::S_JoinRoomRes* Arena::CreateMaybeMessage<::Protocol::S_JoinRoomRes>(Arena*);
template<> ::Protocol::S_KickPlayer* Arena::CreateMaybeMessage<::Protocol::S_KickPlayer>(Arena*);
template<> ::Protocol::S_LeaveRoomRes* Arena::CreateMaybeMessage<::Protocol::S_LeaveRoomRes>(Arena*);
template<> ::Protocol::S_Ping* Arena::CreateMaybeMessage<::Protocol::S_Ping>(Arena*);
template<> ::Protocol::S_RoomListRes* Arena::CreateMaybeMessage<::Protocol::S_RoomListRes>(Arena*);
template<> ::Protocol::S_SelectRoomRes* Arena::CreateMaybeMessage<::Protocol::S_SelectRoomRes>(Arena*);
template<> ::Protocol::S_StartGameRes* Arena::CreateMaybeMessage<::Protocol::S_StartGameRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class S_Connected final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_Connected) */ {
 public:
  inline S_Connected() : S_Connected(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_Connected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Connected(const S_Connected& from);
  S_Connected(S_Connected&& from) noexcept
    : S_Connected() {
    *this = ::std::move(from);
  }

  inline S_Connected& operator=(const S_Connected& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Connected& operator=(S_Connected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Connected& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Connected* internal_default_instance() {
    return reinterpret_cast<const S_Connected*>(
               &_S_Connected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(S_Connected& a, S_Connected& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Connected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Connected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Connected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Connected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_Connected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_Connected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Connected";
  }
  protected:
  explicit S_Connected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_Connected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AuthReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AuthReq) */ {
 public:
  inline C_AuthReq() : C_AuthReq(nullptr) {}
  ~C_AuthReq() override;
  explicit PROTOBUF_CONSTEXPR C_AuthReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AuthReq(const C_AuthReq& from);
  C_AuthReq(C_AuthReq&& from) noexcept
    : C_AuthReq() {
    *this = ::std::move(from);
  }

  inline C_AuthReq& operator=(const C_AuthReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AuthReq& operator=(C_AuthReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AuthReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AuthReq* internal_default_instance() {
    return reinterpret_cast<const C_AuthReq*>(
               &_C_AuthReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(C_AuthReq& a, C_AuthReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AuthReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AuthReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AuthReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AuthReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AuthReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AuthReq& from) {
    C_AuthReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AuthReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AuthReq";
  }
  protected:
  explicit C_AuthReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJwtFieldNumber = 1,
  };
  // string jwt = 1;
  void clear_jwt();
  const std::string& jwt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jwt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jwt();
  PROTOBUF_NODISCARD std::string* release_jwt();
  void set_allocated_jwt(std::string* jwt);
  private:
  const std::string& _internal_jwt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jwt(const std::string& value);
  std::string* _internal_mutable_jwt();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AuthReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jwt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AuthRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AuthRes) */ {
 public:
  inline S_AuthRes() : S_AuthRes(nullptr) {}
  ~S_AuthRes() override;
  explicit PROTOBUF_CONSTEXPR S_AuthRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AuthRes(const S_AuthRes& from);
  S_AuthRes(S_AuthRes&& from) noexcept
    : S_AuthRes() {
    *this = ::std::move(from);
  }

  inline S_AuthRes& operator=(const S_AuthRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AuthRes& operator=(S_AuthRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AuthRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AuthRes* internal_default_instance() {
    return reinterpret_cast<const S_AuthRes*>(
               &_S_AuthRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_AuthRes& a, S_AuthRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AuthRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AuthRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AuthRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AuthRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AuthRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AuthRes& from) {
    S_AuthRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AuthRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AuthRes";
  }
  protected:
  explicit S_AuthRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AuthRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterLobbyReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_EnterLobbyReq) */ {
 public:
  inline C_EnterLobbyReq() : C_EnterLobbyReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_EnterLobbyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterLobbyReq(const C_EnterLobbyReq& from);
  C_EnterLobbyReq(C_EnterLobbyReq&& from) noexcept
    : C_EnterLobbyReq() {
    *this = ::std::move(from);
  }

  inline C_EnterLobbyReq& operator=(const C_EnterLobbyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterLobbyReq& operator=(C_EnterLobbyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterLobbyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterLobbyReq* internal_default_instance() {
    return reinterpret_cast<const C_EnterLobbyReq*>(
               &_C_EnterLobbyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(C_EnterLobbyReq& a, C_EnterLobbyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterLobbyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterLobbyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EnterLobbyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EnterLobbyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_EnterLobbyReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_EnterLobbyReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterLobbyReq";
  }
  protected:
  explicit C_EnterLobbyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterLobbyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EnterLobbyRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterLobbyRes) */ {
 public:
  inline S_EnterLobbyRes() : S_EnterLobbyRes(nullptr) {}
  ~S_EnterLobbyRes() override;
  explicit PROTOBUF_CONSTEXPR S_EnterLobbyRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterLobbyRes(const S_EnterLobbyRes& from);
  S_EnterLobbyRes(S_EnterLobbyRes&& from) noexcept
    : S_EnterLobbyRes() {
    *this = ::std::move(from);
  }

  inline S_EnterLobbyRes& operator=(const S_EnterLobbyRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterLobbyRes& operator=(S_EnterLobbyRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterLobbyRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterLobbyRes* internal_default_instance() {
    return reinterpret_cast<const S_EnterLobbyRes*>(
               &_S_EnterLobbyRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(S_EnterLobbyRes& a, S_EnterLobbyRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterLobbyRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterLobbyRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnterLobbyRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EnterLobbyRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EnterLobbyRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EnterLobbyRes& from) {
    S_EnterLobbyRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterLobbyRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterLobbyRes";
  }
  protected:
  explicit S_EnterLobbyRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .Protocol.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::Protocol::RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
      mutable_rooms();
  private:
  const ::Protocol::RoomInfo& _internal_rooms(int index) const;
  ::Protocol::RoomInfo* _internal_add_rooms();
  public:
  const ::Protocol::RoomInfo& rooms(int index) const;
  ::Protocol::RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterLobbyRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LobbyChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LobbyChat) */ {
 public:
  inline C_LobbyChat() : C_LobbyChat(nullptr) {}
  ~C_LobbyChat() override;
  explicit PROTOBUF_CONSTEXPR C_LobbyChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LobbyChat(const C_LobbyChat& from);
  C_LobbyChat(C_LobbyChat&& from) noexcept
    : C_LobbyChat() {
    *this = ::std::move(from);
  }

  inline C_LobbyChat& operator=(const C_LobbyChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LobbyChat& operator=(C_LobbyChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LobbyChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LobbyChat* internal_default_instance() {
    return reinterpret_cast<const C_LobbyChat*>(
               &_C_LobbyChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_LobbyChat& a, C_LobbyChat& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LobbyChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LobbyChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LobbyChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LobbyChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LobbyChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LobbyChat& from) {
    C_LobbyChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LobbyChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LobbyChat";
  }
  protected:
  explicit C_LobbyChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LobbyChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastLobbyChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastLobbyChat) */ {
 public:
  inline S_BroadcastLobbyChat() : S_BroadcastLobbyChat(nullptr) {}
  ~S_BroadcastLobbyChat() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastLobbyChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastLobbyChat(const S_BroadcastLobbyChat& from);
  S_BroadcastLobbyChat(S_BroadcastLobbyChat&& from) noexcept
    : S_BroadcastLobbyChat() {
    *this = ::std::move(from);
  }

  inline S_BroadcastLobbyChat& operator=(const S_BroadcastLobbyChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastLobbyChat& operator=(S_BroadcastLobbyChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastLobbyChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastLobbyChat* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastLobbyChat*>(
               &_S_BroadcastLobbyChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_BroadcastLobbyChat& a, S_BroadcastLobbyChat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastLobbyChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastLobbyChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastLobbyChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastLobbyChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastLobbyChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastLobbyChat& from) {
    S_BroadcastLobbyChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastLobbyChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastLobbyChat";
  }
  protected:
  explicit S_BroadcastLobbyChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
  };
  // string playerName = 2;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastLobbyChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_RoomListReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_RoomListReq) */ {
 public:
  inline C_RoomListReq() : C_RoomListReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_RoomListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RoomListReq(const C_RoomListReq& from);
  C_RoomListReq(C_RoomListReq&& from) noexcept
    : C_RoomListReq() {
    *this = ::std::move(from);
  }

  inline C_RoomListReq& operator=(const C_RoomListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RoomListReq& operator=(C_RoomListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RoomListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RoomListReq* internal_default_instance() {
    return reinterpret_cast<const C_RoomListReq*>(
               &_C_RoomListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_RoomListReq& a, C_RoomListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RoomListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RoomListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_RoomListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_RoomListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_RoomListReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_RoomListReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_RoomListReq";
  }
  protected:
  explicit C_RoomListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_RoomListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_RoomListRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_RoomListRes) */ {
 public:
  inline S_RoomListRes() : S_RoomListRes(nullptr) {}
  ~S_RoomListRes() override;
  explicit PROTOBUF_CONSTEXPR S_RoomListRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RoomListRes(const S_RoomListRes& from);
  S_RoomListRes(S_RoomListRes&& from) noexcept
    : S_RoomListRes() {
    *this = ::std::move(from);
  }

  inline S_RoomListRes& operator=(const S_RoomListRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RoomListRes& operator=(S_RoomListRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RoomListRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RoomListRes* internal_default_instance() {
    return reinterpret_cast<const S_RoomListRes*>(
               &_S_RoomListRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_RoomListRes& a, S_RoomListRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RoomListRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RoomListRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_RoomListRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_RoomListRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_RoomListRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_RoomListRes& from) {
    S_RoomListRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RoomListRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_RoomListRes";
  }
  protected:
  explicit S_RoomListRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .Protocol.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::Protocol::RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
      mutable_rooms();
  private:
  const ::Protocol::RoomInfo& _internal_rooms(int index) const;
  ::Protocol::RoomInfo* _internal_add_rooms();
  public:
  const ::Protocol::RoomInfo& rooms(int index) const;
  ::Protocol::RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_RoomListRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SelectRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SelectRoomReq) */ {
 public:
  inline C_SelectRoomReq() : C_SelectRoomReq(nullptr) {}
  ~C_SelectRoomReq() override;
  explicit PROTOBUF_CONSTEXPR C_SelectRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SelectRoomReq(const C_SelectRoomReq& from);
  C_SelectRoomReq(C_SelectRoomReq&& from) noexcept
    : C_SelectRoomReq() {
    *this = ::std::move(from);
  }

  inline C_SelectRoomReq& operator=(const C_SelectRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SelectRoomReq& operator=(C_SelectRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SelectRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SelectRoomReq* internal_default_instance() {
    return reinterpret_cast<const C_SelectRoomReq*>(
               &_C_SelectRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_SelectRoomReq& a, C_SelectRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SelectRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SelectRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SelectRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SelectRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SelectRoomReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SelectRoomReq& from) {
    C_SelectRoomReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SelectRoomReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SelectRoomReq";
  }
  protected:
  explicit C_SelectRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 roomId = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SelectRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SelectRoomRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SelectRoomRes) */ {
 public:
  inline S_SelectRoomRes() : S_SelectRoomRes(nullptr) {}
  ~S_SelectRoomRes() override;
  explicit PROTOBUF_CONSTEXPR S_SelectRoomRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SelectRoomRes(const S_SelectRoomRes& from);
  S_SelectRoomRes(S_SelectRoomRes&& from) noexcept
    : S_SelectRoomRes() {
    *this = ::std::move(from);
  }

  inline S_SelectRoomRes& operator=(const S_SelectRoomRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SelectRoomRes& operator=(S_SelectRoomRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SelectRoomRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SelectRoomRes* internal_default_instance() {
    return reinterpret_cast<const S_SelectRoomRes*>(
               &_S_SelectRoomRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_SelectRoomRes& a, S_SelectRoomRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SelectRoomRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SelectRoomRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SelectRoomRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SelectRoomRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SelectRoomRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SelectRoomRes& from) {
    S_SelectRoomRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SelectRoomRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SelectRoomRes";
  }
  protected:
  explicit S_SelectRoomRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kRoomFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string errorMessage = 3;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // .Protocol.RoomInfo room = 2;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::Protocol::RoomInfo& room() const;
  PROTOBUF_NODISCARD ::Protocol::RoomInfo* release_room();
  ::Protocol::RoomInfo* mutable_room();
  void set_allocated_room(::Protocol::RoomInfo* room);
  private:
  const ::Protocol::RoomInfo& _internal_room() const;
  ::Protocol::RoomInfo* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::Protocol::RoomInfo* room);
  ::Protocol::RoomInfo* unsafe_arena_release_room();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SelectRoomRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    ::Protocol::RoomInfo* room_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CreateRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CreateRoomReq) */ {
 public:
  inline C_CreateRoomReq() : C_CreateRoomReq(nullptr) {}
  ~C_CreateRoomReq() override;
  explicit PROTOBUF_CONSTEXPR C_CreateRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CreateRoomReq(const C_CreateRoomReq& from);
  C_CreateRoomReq(C_CreateRoomReq&& from) noexcept
    : C_CreateRoomReq() {
    *this = ::std::move(from);
  }

  inline C_CreateRoomReq& operator=(const C_CreateRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CreateRoomReq& operator=(C_CreateRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CreateRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CreateRoomReq* internal_default_instance() {
    return reinterpret_cast<const C_CreateRoomReq*>(
               &_C_CreateRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_CreateRoomReq& a, C_CreateRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CreateRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CreateRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CreateRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CreateRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CreateRoomReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CreateRoomReq& from) {
    C_CreateRoomReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CreateRoomReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CreateRoomReq";
  }
  protected:
  explicit C_CreateRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kMapNameFieldNumber = 4,
    kModeFieldNumber = 2,
    kMaxPlayersFieldNumber = 3,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string mapName = 4;
  void clear_mapname();
  const std::string& mapname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapname();
  PROTOBUF_NODISCARD std::string* release_mapname();
  void set_allocated_mapname(std::string* mapname);
  private:
  const std::string& _internal_mapname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapname(const std::string& value);
  std::string* _internal_mutable_mapname();
  public:

  // .Protocol.EGameMode mode = 2;
  void clear_mode();
  ::Protocol::EGameMode mode() const;
  void set_mode(::Protocol::EGameMode value);
  private:
  ::Protocol::EGameMode _internal_mode() const;
  void _internal_set_mode(::Protocol::EGameMode value);
  public:

  // int32 maxPlayers = 3;
  void clear_maxplayers();
  int32_t maxplayers() const;
  void set_maxplayers(int32_t value);
  private:
  int32_t _internal_maxplayers() const;
  void _internal_set_maxplayers(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CreateRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapname_;
    int mode_;
    int32_t maxplayers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CreateRoomRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CreateRoomRes) */ {
 public:
  inline S_CreateRoomRes() : S_CreateRoomRes(nullptr) {}
  ~S_CreateRoomRes() override;
  explicit PROTOBUF_CONSTEXPR S_CreateRoomRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreateRoomRes(const S_CreateRoomRes& from);
  S_CreateRoomRes(S_CreateRoomRes&& from) noexcept
    : S_CreateRoomRes() {
    *this = ::std::move(from);
  }

  inline S_CreateRoomRes& operator=(const S_CreateRoomRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreateRoomRes& operator=(S_CreateRoomRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreateRoomRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreateRoomRes* internal_default_instance() {
    return reinterpret_cast<const S_CreateRoomRes*>(
               &_S_CreateRoomRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_CreateRoomRes& a, S_CreateRoomRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreateRoomRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreateRoomRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CreateRoomRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CreateRoomRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CreateRoomRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CreateRoomRes& from) {
    S_CreateRoomRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreateRoomRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CreateRoomRes";
  }
  protected:
  explicit S_CreateRoomRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kRoomFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string errorMessage = 3;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // .Protocol.RoomInfo room = 2;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::Protocol::RoomInfo& room() const;
  PROTOBUF_NODISCARD ::Protocol::RoomInfo* release_room();
  ::Protocol::RoomInfo* mutable_room();
  void set_allocated_room(::Protocol::RoomInfo* room);
  private:
  const ::Protocol::RoomInfo& _internal_room() const;
  ::Protocol::RoomInfo* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::Protocol::RoomInfo* room);
  ::Protocol::RoomInfo* unsafe_arena_release_room();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CreateRoomRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    ::Protocol::RoomInfo* room_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_JoinRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_JoinRoomReq) */ {
 public:
  inline C_JoinRoomReq() : C_JoinRoomReq(nullptr) {}
  ~C_JoinRoomReq() override;
  explicit PROTOBUF_CONSTEXPR C_JoinRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_JoinRoomReq(const C_JoinRoomReq& from);
  C_JoinRoomReq(C_JoinRoomReq&& from) noexcept
    : C_JoinRoomReq() {
    *this = ::std::move(from);
  }

  inline C_JoinRoomReq& operator=(const C_JoinRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_JoinRoomReq& operator=(C_JoinRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_JoinRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_JoinRoomReq* internal_default_instance() {
    return reinterpret_cast<const C_JoinRoomReq*>(
               &_C_JoinRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_JoinRoomReq& a, C_JoinRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_JoinRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_JoinRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_JoinRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_JoinRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_JoinRoomReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_JoinRoomReq& from) {
    C_JoinRoomReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_JoinRoomReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_JoinRoomReq";
  }
  protected:
  explicit C_JoinRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 roomId = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_JoinRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_JoinRoomRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_JoinRoomRes) */ {
 public:
  inline S_JoinRoomRes() : S_JoinRoomRes(nullptr) {}
  ~S_JoinRoomRes() override;
  explicit PROTOBUF_CONSTEXPR S_JoinRoomRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_JoinRoomRes(const S_JoinRoomRes& from);
  S_JoinRoomRes(S_JoinRoomRes&& from) noexcept
    : S_JoinRoomRes() {
    *this = ::std::move(from);
  }

  inline S_JoinRoomRes& operator=(const S_JoinRoomRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_JoinRoomRes& operator=(S_JoinRoomRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_JoinRoomRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_JoinRoomRes* internal_default_instance() {
    return reinterpret_cast<const S_JoinRoomRes*>(
               &_S_JoinRoomRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_JoinRoomRes& a, S_JoinRoomRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_JoinRoomRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_JoinRoomRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_JoinRoomRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_JoinRoomRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_JoinRoomRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_JoinRoomRes& from) {
    S_JoinRoomRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_JoinRoomRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_JoinRoomRes";
  }
  protected:
  explicit S_JoinRoomRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kRoomFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string errorMessage = 3;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // .Protocol.RoomInfo room = 2;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::Protocol::RoomInfo& room() const;
  PROTOBUF_NODISCARD ::Protocol::RoomInfo* release_room();
  ::Protocol::RoomInfo* mutable_room();
  void set_allocated_room(::Protocol::RoomInfo* room);
  private:
  const ::Protocol::RoomInfo& _internal_room() const;
  ::Protocol::RoomInfo* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::Protocol::RoomInfo* room);
  ::Protocol::RoomInfo* unsafe_arena_release_room();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_JoinRoomRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    ::Protocol::RoomInfo* room_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastJoinRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastJoinRoom) */ {
 public:
  inline S_BroadcastJoinRoom() : S_BroadcastJoinRoom(nullptr) {}
  ~S_BroadcastJoinRoom() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastJoinRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastJoinRoom(const S_BroadcastJoinRoom& from);
  S_BroadcastJoinRoom(S_BroadcastJoinRoom&& from) noexcept
    : S_BroadcastJoinRoom() {
    *this = ::std::move(from);
  }

  inline S_BroadcastJoinRoom& operator=(const S_BroadcastJoinRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastJoinRoom& operator=(S_BroadcastJoinRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastJoinRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastJoinRoom* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastJoinRoom*>(
               &_S_BroadcastJoinRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_BroadcastJoinRoom& a, S_BroadcastJoinRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastJoinRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastJoinRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastJoinRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastJoinRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastJoinRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastJoinRoom& from) {
    S_BroadcastJoinRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastJoinRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastJoinRoom";
  }
  protected:
  explicit S_BroadcastJoinRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPlayerFieldNumber = 1,
  };
  // .Protocol.PlayerInfo newPlayer = 1;
  bool has_newplayer() const;
  private:
  bool _internal_has_newplayer() const;
  public:
  void clear_newplayer();
  const ::Protocol::PlayerInfo& newplayer() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_newplayer();
  ::Protocol::PlayerInfo* mutable_newplayer();
  void set_allocated_newplayer(::Protocol::PlayerInfo* newplayer);
  private:
  const ::Protocol::PlayerInfo& _internal_newplayer() const;
  ::Protocol::PlayerInfo* _internal_mutable_newplayer();
  public:
  void unsafe_arena_set_allocated_newplayer(
      ::Protocol::PlayerInfo* newplayer);
  ::Protocol::PlayerInfo* unsafe_arena_release_newplayer();

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastJoinRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* newplayer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LeaveRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LeaveRoomReq) */ {
 public:
  inline C_LeaveRoomReq() : C_LeaveRoomReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LeaveRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LeaveRoomReq(const C_LeaveRoomReq& from);
  C_LeaveRoomReq(C_LeaveRoomReq&& from) noexcept
    : C_LeaveRoomReq() {
    *this = ::std::move(from);
  }

  inline C_LeaveRoomReq& operator=(const C_LeaveRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LeaveRoomReq& operator=(C_LeaveRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LeaveRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LeaveRoomReq* internal_default_instance() {
    return reinterpret_cast<const C_LeaveRoomReq*>(
               &_C_LeaveRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(C_LeaveRoomReq& a, C_LeaveRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LeaveRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LeaveRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LeaveRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LeaveRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LeaveRoomReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LeaveRoomReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LeaveRoomReq";
  }
  protected:
  explicit C_LeaveRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LeaveRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LeaveRoomRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LeaveRoomRes) */ {
 public:
  inline S_LeaveRoomRes() : S_LeaveRoomRes(nullptr) {}
  ~S_LeaveRoomRes() override;
  explicit PROTOBUF_CONSTEXPR S_LeaveRoomRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LeaveRoomRes(const S_LeaveRoomRes& from);
  S_LeaveRoomRes(S_LeaveRoomRes&& from) noexcept
    : S_LeaveRoomRes() {
    *this = ::std::move(from);
  }

  inline S_LeaveRoomRes& operator=(const S_LeaveRoomRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LeaveRoomRes& operator=(S_LeaveRoomRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LeaveRoomRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LeaveRoomRes* internal_default_instance() {
    return reinterpret_cast<const S_LeaveRoomRes*>(
               &_S_LeaveRoomRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_LeaveRoomRes& a, S_LeaveRoomRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LeaveRoomRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LeaveRoomRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LeaveRoomRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LeaveRoomRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LeaveRoomRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LeaveRoomRes& from) {
    S_LeaveRoomRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LeaveRoomRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LeaveRoomRes";
  }
  protected:
  explicit S_LeaveRoomRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LeaveRoomRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastLeaveRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastLeaveRoom) */ {
 public:
  inline S_BroadcastLeaveRoom() : S_BroadcastLeaveRoom(nullptr) {}
  ~S_BroadcastLeaveRoom() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastLeaveRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastLeaveRoom(const S_BroadcastLeaveRoom& from);
  S_BroadcastLeaveRoom(S_BroadcastLeaveRoom&& from) noexcept
    : S_BroadcastLeaveRoom() {
    *this = ::std::move(from);
  }

  inline S_BroadcastLeaveRoom& operator=(const S_BroadcastLeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastLeaveRoom& operator=(S_BroadcastLeaveRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastLeaveRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastLeaveRoom* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastLeaveRoom*>(
               &_S_BroadcastLeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_BroadcastLeaveRoom& a, S_BroadcastLeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastLeaveRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastLeaveRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastLeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastLeaveRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastLeaveRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastLeaveRoom& from) {
    S_BroadcastLeaveRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastLeaveRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastLeaveRoom";
  }
  protected:
  explicit S_BroadcastLeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kIsHostFieldNumber = 2,
  };
  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // bool isHost = 2;
  void clear_ishost();
  bool ishost() const;
  void set_ishost(bool value);
  private:
  bool _internal_ishost() const;
  void _internal_set_ishost(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastLeaveRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t playerid_;
    bool ishost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_RoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_RoomChat) */ {
 public:
  inline C_RoomChat() : C_RoomChat(nullptr) {}
  ~C_RoomChat() override;
  explicit PROTOBUF_CONSTEXPR C_RoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RoomChat(const C_RoomChat& from);
  C_RoomChat(C_RoomChat&& from) noexcept
    : C_RoomChat() {
    *this = ::std::move(from);
  }

  inline C_RoomChat& operator=(const C_RoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RoomChat& operator=(C_RoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RoomChat* internal_default_instance() {
    return reinterpret_cast<const C_RoomChat*>(
               &_C_RoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_RoomChat& a, C_RoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_RoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_RoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_RoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_RoomChat& from) {
    C_RoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_RoomChat";
  }
  protected:
  explicit C_RoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_RoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastRoomChat) */ {
 public:
  inline S_BroadcastRoomChat() : S_BroadcastRoomChat(nullptr) {}
  ~S_BroadcastRoomChat() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastRoomChat(const S_BroadcastRoomChat& from);
  S_BroadcastRoomChat(S_BroadcastRoomChat&& from) noexcept
    : S_BroadcastRoomChat() {
    *this = ::std::move(from);
  }

  inline S_BroadcastRoomChat& operator=(const S_BroadcastRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastRoomChat& operator=(S_BroadcastRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastRoomChat* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastRoomChat*>(
               &_S_BroadcastRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_BroadcastRoomChat& a, S_BroadcastRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastRoomChat& from) {
    S_BroadcastRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastRoomChat";
  }
  protected:
  explicit S_BroadcastRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
  };
  // string playerName = 2;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ReadyGameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ReadyGameReq) */ {
 public:
  inline C_ReadyGameReq() : C_ReadyGameReq(nullptr) {}
  ~C_ReadyGameReq() override;
  explicit PROTOBUF_CONSTEXPR C_ReadyGameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ReadyGameReq(const C_ReadyGameReq& from);
  C_ReadyGameReq(C_ReadyGameReq&& from) noexcept
    : C_ReadyGameReq() {
    *this = ::std::move(from);
  }

  inline C_ReadyGameReq& operator=(const C_ReadyGameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ReadyGameReq& operator=(C_ReadyGameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ReadyGameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ReadyGameReq* internal_default_instance() {
    return reinterpret_cast<const C_ReadyGameReq*>(
               &_C_ReadyGameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_ReadyGameReq& a, C_ReadyGameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ReadyGameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ReadyGameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ReadyGameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ReadyGameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ReadyGameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ReadyGameReq& from) {
    C_ReadyGameReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ReadyGameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ReadyGameReq";
  }
  protected:
  explicit C_ReadyGameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ReadyGameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastReadyGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastReadyGame) */ {
 public:
  inline S_BroadcastReadyGame() : S_BroadcastReadyGame(nullptr) {}
  ~S_BroadcastReadyGame() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastReadyGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastReadyGame(const S_BroadcastReadyGame& from);
  S_BroadcastReadyGame(S_BroadcastReadyGame&& from) noexcept
    : S_BroadcastReadyGame() {
    *this = ::std::move(from);
  }

  inline S_BroadcastReadyGame& operator=(const S_BroadcastReadyGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastReadyGame& operator=(S_BroadcastReadyGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastReadyGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastReadyGame* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastReadyGame*>(
               &_S_BroadcastReadyGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_BroadcastReadyGame& a, S_BroadcastReadyGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastReadyGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastReadyGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastReadyGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastReadyGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastReadyGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastReadyGame& from) {
    S_BroadcastReadyGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastReadyGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastReadyGame";
  }
  protected:
  explicit S_BroadcastReadyGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kReadyFieldNumber = 2,
  };
  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // bool ready = 2;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastReadyGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t playerid_;
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_StartGameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_StartGameReq) */ {
 public:
  inline C_StartGameReq() : C_StartGameReq(nullptr) {}
  ~C_StartGameReq() override;
  explicit PROTOBUF_CONSTEXPR C_StartGameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_StartGameReq(const C_StartGameReq& from);
  C_StartGameReq(C_StartGameReq&& from) noexcept
    : C_StartGameReq() {
    *this = ::std::move(from);
  }

  inline C_StartGameReq& operator=(const C_StartGameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_StartGameReq& operator=(C_StartGameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_StartGameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_StartGameReq* internal_default_instance() {
    return reinterpret_cast<const C_StartGameReq*>(
               &_C_StartGameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_StartGameReq& a, C_StartGameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_StartGameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_StartGameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_StartGameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_StartGameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_StartGameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_StartGameReq& from) {
    C_StartGameReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_StartGameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_StartGameReq";
  }
  protected:
  explicit C_StartGameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string hostAddress = 1;
  void clear_hostaddress();
  const std::string& hostaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostaddress();
  PROTOBUF_NODISCARD std::string* release_hostaddress();
  void set_allocated_hostaddress(std::string* hostaddress);
  private:
  const std::string& _internal_hostaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostaddress(const std::string& value);
  std::string* _internal_mutable_hostaddress();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_StartGameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostaddress_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_StartGameRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_StartGameRes) */ {
 public:
  inline S_StartGameRes() : S_StartGameRes(nullptr) {}
  ~S_StartGameRes() override;
  explicit PROTOBUF_CONSTEXPR S_StartGameRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_StartGameRes(const S_StartGameRes& from);
  S_StartGameRes(S_StartGameRes&& from) noexcept
    : S_StartGameRes() {
    *this = ::std::move(from);
  }

  inline S_StartGameRes& operator=(const S_StartGameRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_StartGameRes& operator=(S_StartGameRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_StartGameRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_StartGameRes* internal_default_instance() {
    return reinterpret_cast<const S_StartGameRes*>(
               &_S_StartGameRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_StartGameRes& a, S_StartGameRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_StartGameRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_StartGameRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_StartGameRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_StartGameRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_StartGameRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_StartGameRes& from) {
    S_StartGameRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_StartGameRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_StartGameRes";
  }
  protected:
  explicit S_StartGameRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated .Protocol.PlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // string errorMessage = 3;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_StartGameRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastStartGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastStartGame) */ {
 public:
  inline S_BroadcastStartGame() : S_BroadcastStartGame(nullptr) {}
  ~S_BroadcastStartGame() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastStartGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastStartGame(const S_BroadcastStartGame& from);
  S_BroadcastStartGame(S_BroadcastStartGame&& from) noexcept
    : S_BroadcastStartGame() {
    *this = ::std::move(from);
  }

  inline S_BroadcastStartGame& operator=(const S_BroadcastStartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastStartGame& operator=(S_BroadcastStartGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastStartGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastStartGame* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastStartGame*>(
               &_S_BroadcastStartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(S_BroadcastStartGame& a, S_BroadcastStartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastStartGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastStartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastStartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastStartGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastStartGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastStartGame& from) {
    S_BroadcastStartGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastStartGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastStartGame";
  }
  protected:
  explicit S_BroadcastStartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostAddressFieldNumber = 1,
    kPortFieldNumber = 2,
    kSessionIdFieldNumber = 3,
  };
  // string hostAddress = 1;
  void clear_hostaddress();
  const std::string& hostaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostaddress();
  PROTOBUF_NODISCARD std::string* release_hostaddress();
  void set_allocated_hostaddress(std::string* hostaddress);
  private:
  const std::string& _internal_hostaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostaddress(const std::string& value);
  std::string* _internal_mutable_hostaddress();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // int32 sessionId = 3;
  void clear_sessionid();
  int32_t sessionid() const;
  void set_sessionid(int32_t value);
  private:
  int32_t _internal_sessionid() const;
  void _internal_set_sessionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastStartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostaddress_;
    int32_t port_;
    int32_t sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EndGameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EndGameReq) */ {
 public:
  inline C_EndGameReq() : C_EndGameReq(nullptr) {}
  ~C_EndGameReq() override;
  explicit PROTOBUF_CONSTEXPR C_EndGameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EndGameReq(const C_EndGameReq& from);
  C_EndGameReq(C_EndGameReq&& from) noexcept
    : C_EndGameReq() {
    *this = ::std::move(from);
  }

  inline C_EndGameReq& operator=(const C_EndGameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EndGameReq& operator=(C_EndGameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EndGameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EndGameReq* internal_default_instance() {
    return reinterpret_cast<const C_EndGameReq*>(
               &_C_EndGameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_EndGameReq& a, C_EndGameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EndGameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EndGameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EndGameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EndGameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EndGameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EndGameReq& from) {
    C_EndGameReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EndGameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EndGameReq";
  }
  protected:
  explicit C_EndGameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EndGameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EndGameRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EndGameRes) */ {
 public:
  inline S_EndGameRes() : S_EndGameRes(nullptr) {}
  ~S_EndGameRes() override;
  explicit PROTOBUF_CONSTEXPR S_EndGameRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EndGameRes(const S_EndGameRes& from);
  S_EndGameRes(S_EndGameRes&& from) noexcept
    : S_EndGameRes() {
    *this = ::std::move(from);
  }

  inline S_EndGameRes& operator=(const S_EndGameRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EndGameRes& operator=(S_EndGameRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EndGameRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EndGameRes* internal_default_instance() {
    return reinterpret_cast<const S_EndGameRes*>(
               &_S_EndGameRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_EndGameRes& a, S_EndGameRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EndGameRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EndGameRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EndGameRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EndGameRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EndGameRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EndGameRes& from) {
    S_EndGameRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EndGameRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EndGameRes";
  }
  protected:
  explicit S_EndGameRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EndGameRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastEndGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastEndGame) */ {
 public:
  inline S_BroadcastEndGame() : S_BroadcastEndGame(nullptr) {}
  ~S_BroadcastEndGame() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastEndGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastEndGame(const S_BroadcastEndGame& from);
  S_BroadcastEndGame(S_BroadcastEndGame&& from) noexcept
    : S_BroadcastEndGame() {
    *this = ::std::move(from);
  }

  inline S_BroadcastEndGame& operator=(const S_BroadcastEndGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastEndGame& operator=(S_BroadcastEndGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastEndGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastEndGame* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastEndGame*>(
               &_S_BroadcastEndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_BroadcastEndGame& a, S_BroadcastEndGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastEndGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastEndGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastEndGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastEndGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastEndGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastEndGame& from) {
    S_BroadcastEndGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastEndGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastEndGame";
  }
  protected:
  explicit S_BroadcastEndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kNewHostIdFieldNumber = 2,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // int64 newHostId = 2;
  void clear_newhostid();
  int64_t newhostid() const;
  void set_newhostid(int64_t value);
  private:
  int64_t _internal_newhostid() const;
  void _internal_set_newhostid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastEndGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    int64_t newhostid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastChangeHost final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastChangeHost) */ {
 public:
  inline S_BroadcastChangeHost() : S_BroadcastChangeHost(nullptr) {}
  ~S_BroadcastChangeHost() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastChangeHost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastChangeHost(const S_BroadcastChangeHost& from);
  S_BroadcastChangeHost(S_BroadcastChangeHost&& from) noexcept
    : S_BroadcastChangeHost() {
    *this = ::std::move(from);
  }

  inline S_BroadcastChangeHost& operator=(const S_BroadcastChangeHost& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastChangeHost& operator=(S_BroadcastChangeHost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastChangeHost& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastChangeHost* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastChangeHost*>(
               &_S_BroadcastChangeHost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_BroadcastChangeHost& a, S_BroadcastChangeHost& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastChangeHost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastChangeHost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastChangeHost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastChangeHost>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastChangeHost& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastChangeHost& from) {
    S_BroadcastChangeHost::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastChangeHost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastChangeHost";
  }
  protected:
  explicit S_BroadcastChangeHost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 2,
    kNewHostPlayerIdFieldNumber = 1,
  };
  // string playerName = 2;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // int32 newHostPlayerId = 1;
  void clear_newhostplayerid();
  int32_t newhostplayerid() const;
  void set_newhostplayerid(int32_t value);
  private:
  int32_t _internal_newhostplayerid() const;
  void _internal_set_newhostplayerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastChangeHost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    int32_t newhostplayerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastRoomState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastRoomState) */ {
 public:
  inline S_BroadcastRoomState() : S_BroadcastRoomState(nullptr) {}
  ~S_BroadcastRoomState() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastRoomState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastRoomState(const S_BroadcastRoomState& from);
  S_BroadcastRoomState(S_BroadcastRoomState&& from) noexcept
    : S_BroadcastRoomState() {
    *this = ::std::move(from);
  }

  inline S_BroadcastRoomState& operator=(const S_BroadcastRoomState& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastRoomState& operator=(S_BroadcastRoomState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastRoomState& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastRoomState* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastRoomState*>(
               &_S_BroadcastRoomState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(S_BroadcastRoomState& a, S_BroadcastRoomState& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastRoomState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastRoomState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastRoomState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastRoomState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastRoomState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastRoomState& from) {
    S_BroadcastRoomState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastRoomState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastRoomState";
  }
  protected:
  explicit S_BroadcastRoomState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // int32 roomId = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // .Protocol.ERoomState state = 2;
  void clear_state();
  ::Protocol::ERoomState state() const;
  void set_state(::Protocol::ERoomState value);
  private:
  ::Protocol::ERoomState _internal_state() const;
  void _internal_set_state(::Protocol::ERoomState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastRoomState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ErrorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ErrorMessage) */ {
 public:
  inline S_ErrorMessage() : S_ErrorMessage(nullptr) {}
  ~S_ErrorMessage() override;
  explicit PROTOBUF_CONSTEXPR S_ErrorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ErrorMessage(const S_ErrorMessage& from);
  S_ErrorMessage(S_ErrorMessage&& from) noexcept
    : S_ErrorMessage() {
    *this = ::std::move(from);
  }

  inline S_ErrorMessage& operator=(const S_ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ErrorMessage& operator=(S_ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const S_ErrorMessage*>(
               &_S_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_ErrorMessage& a, S_ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ErrorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ErrorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ErrorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ErrorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ErrorMessage& from) {
    S_ErrorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ErrorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ErrorMessage";
  }
  protected:
  explicit S_ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ErrorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_KickPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_KickPlayer) */ {
 public:
  inline S_KickPlayer() : S_KickPlayer(nullptr) {}
  ~S_KickPlayer() override;
  explicit PROTOBUF_CONSTEXPR S_KickPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_KickPlayer(const S_KickPlayer& from);
  S_KickPlayer(S_KickPlayer&& from) noexcept
    : S_KickPlayer() {
    *this = ::std::move(from);
  }

  inline S_KickPlayer& operator=(const S_KickPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_KickPlayer& operator=(S_KickPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_KickPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_KickPlayer* internal_default_instance() {
    return reinterpret_cast<const S_KickPlayer*>(
               &_S_KickPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(S_KickPlayer& a, S_KickPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(S_KickPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_KickPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_KickPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_KickPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_KickPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_KickPlayer& from) {
    S_KickPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_KickPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_KickPlayer";
  }
  protected:
  explicit S_KickPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_KickPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Ping final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_Ping) */ {
 public:
  inline S_Ping() : S_Ping(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Ping(const S_Ping& from);
  S_Ping(S_Ping&& from) noexcept
    : S_Ping() {
    *this = ::std::move(from);
  }

  inline S_Ping& operator=(const S_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Ping& operator=(S_Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Ping* internal_default_instance() {
    return reinterpret_cast<const S_Ping*>(
               &_S_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_Ping& a, S_Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Ping";
  }
  protected:
  explicit S_Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Pong final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_Pong) */ {
 public:
  inline C_Pong() : C_Pong(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Pong(const C_Pong& from);
  C_Pong(C_Pong&& from) noexcept
    : C_Pong() {
    *this = ::std::move(from);
  }

  inline C_Pong& operator=(const C_Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Pong& operator=(C_Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Pong* internal_default_instance() {
    return reinterpret_cast<const C_Pong*>(
               &_C_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_Pong& a, C_Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Pong";
  }
  protected:
  explicit C_Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// S_Connected

// -------------------------------------------------------------------

// C_AuthReq

// string jwt = 1;
inline void C_AuthReq::clear_jwt() {
  _impl_.jwt_.ClearToEmpty();
}
inline const std::string& C_AuthReq::jwt() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AuthReq.jwt)
  return _internal_jwt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_AuthReq::set_jwt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jwt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_AuthReq.jwt)
}
inline std::string* C_AuthReq::mutable_jwt() {
  std::string* _s = _internal_mutable_jwt();
  // @@protoc_insertion_point(field_mutable:Protocol.C_AuthReq.jwt)
  return _s;
}
inline const std::string& C_AuthReq::_internal_jwt() const {
  return _impl_.jwt_.Get();
}
inline void C_AuthReq::_internal_set_jwt(const std::string& value) {
  
  _impl_.jwt_.Set(value, GetArenaForAllocation());
}
inline std::string* C_AuthReq::_internal_mutable_jwt() {
  
  return _impl_.jwt_.Mutable(GetArenaForAllocation());
}
inline std::string* C_AuthReq::release_jwt() {
  // @@protoc_insertion_point(field_release:Protocol.C_AuthReq.jwt)
  return _impl_.jwt_.Release();
}
inline void C_AuthReq::set_allocated_jwt(std::string* jwt) {
  if (jwt != nullptr) {
    
  } else {
    
  }
  _impl_.jwt_.SetAllocated(jwt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jwt_.IsDefault()) {
    _impl_.jwt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_AuthReq.jwt)
}

// -------------------------------------------------------------------

// S_AuthRes

// bool success = 1;
inline void S_AuthRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_AuthRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_AuthRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AuthRes.success)
  return _internal_success();
}
inline void S_AuthRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_AuthRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AuthRes.success)
}

// -------------------------------------------------------------------

// C_EnterLobbyReq

// -------------------------------------------------------------------

// S_EnterLobbyRes

// repeated .Protocol.RoomInfo rooms = 1;
inline int S_EnterLobbyRes::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int S_EnterLobbyRes::rooms_size() const {
  return _internal_rooms_size();
}
inline ::Protocol::RoomInfo* S_EnterLobbyRes::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_EnterLobbyRes.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
S_EnterLobbyRes::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_EnterLobbyRes.rooms)
  return &_impl_.rooms_;
}
inline const ::Protocol::RoomInfo& S_EnterLobbyRes::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::Protocol::RoomInfo& S_EnterLobbyRes::rooms(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterLobbyRes.rooms)
  return _internal_rooms(index);
}
inline ::Protocol::RoomInfo* S_EnterLobbyRes::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::Protocol::RoomInfo* S_EnterLobbyRes::add_rooms() {
  ::Protocol::RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:Protocol.S_EnterLobbyRes.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
S_EnterLobbyRes::rooms() const {
  // @@protoc_insertion_point(field_list:Protocol.S_EnterLobbyRes.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// C_LobbyChat

// string message = 1;
inline void C_LobbyChat::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& C_LobbyChat::message() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LobbyChat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LobbyChat::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LobbyChat.message)
}
inline std::string* C_LobbyChat::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LobbyChat.message)
  return _s;
}
inline const std::string& C_LobbyChat::_internal_message() const {
  return _impl_.message_.Get();
}
inline void C_LobbyChat::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LobbyChat::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LobbyChat::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.C_LobbyChat.message)
  return _impl_.message_.Release();
}
inline void C_LobbyChat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LobbyChat.message)
}

// -------------------------------------------------------------------

// S_BroadcastLobbyChat

// int32 playerId = 1;
inline void S_BroadcastLobbyChat::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t S_BroadcastLobbyChat::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t S_BroadcastLobbyChat::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastLobbyChat.playerId)
  return _internal_playerid();
}
inline void S_BroadcastLobbyChat::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_BroadcastLobbyChat::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastLobbyChat.playerId)
}

// string playerName = 2;
inline void S_BroadcastLobbyChat::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& S_BroadcastLobbyChat::playername() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastLobbyChat.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastLobbyChat::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastLobbyChat.playerName)
}
inline std::string* S_BroadcastLobbyChat::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastLobbyChat.playerName)
  return _s;
}
inline const std::string& S_BroadcastLobbyChat::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void S_BroadcastLobbyChat::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastLobbyChat::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastLobbyChat::release_playername() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastLobbyChat.playerName)
  return _impl_.playername_.Release();
}
inline void S_BroadcastLobbyChat::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastLobbyChat.playerName)
}

// string message = 3;
inline void S_BroadcastLobbyChat::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& S_BroadcastLobbyChat::message() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastLobbyChat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastLobbyChat::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastLobbyChat.message)
}
inline std::string* S_BroadcastLobbyChat::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastLobbyChat.message)
  return _s;
}
inline const std::string& S_BroadcastLobbyChat::_internal_message() const {
  return _impl_.message_.Get();
}
inline void S_BroadcastLobbyChat::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastLobbyChat::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastLobbyChat::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastLobbyChat.message)
  return _impl_.message_.Release();
}
inline void S_BroadcastLobbyChat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastLobbyChat.message)
}

// -------------------------------------------------------------------

// C_RoomListReq

// -------------------------------------------------------------------

// S_RoomListRes

// repeated .Protocol.RoomInfo rooms = 1;
inline int S_RoomListRes::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int S_RoomListRes::rooms_size() const {
  return _internal_rooms_size();
}
inline ::Protocol::RoomInfo* S_RoomListRes::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_RoomListRes.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
S_RoomListRes::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_RoomListRes.rooms)
  return &_impl_.rooms_;
}
inline const ::Protocol::RoomInfo& S_RoomListRes::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::Protocol::RoomInfo& S_RoomListRes::rooms(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_RoomListRes.rooms)
  return _internal_rooms(index);
}
inline ::Protocol::RoomInfo* S_RoomListRes::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::Protocol::RoomInfo* S_RoomListRes::add_rooms() {
  ::Protocol::RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:Protocol.S_RoomListRes.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
S_RoomListRes::rooms() const {
  // @@protoc_insertion_point(field_list:Protocol.S_RoomListRes.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// C_SelectRoomReq

// int32 roomId = 1;
inline void C_SelectRoomReq::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C_SelectRoomReq::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C_SelectRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SelectRoomReq.roomId)
  return _internal_roomid();
}
inline void C_SelectRoomReq::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C_SelectRoomReq::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SelectRoomReq.roomId)
}

// -------------------------------------------------------------------

// S_SelectRoomRes

// bool success = 1;
inline void S_SelectRoomRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_SelectRoomRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_SelectRoomRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SelectRoomRes.success)
  return _internal_success();
}
inline void S_SelectRoomRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_SelectRoomRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SelectRoomRes.success)
}

// .Protocol.RoomInfo room = 2;
inline bool S_SelectRoomRes::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool S_SelectRoomRes::has_room() const {
  return _internal_has_room();
}
inline const ::Protocol::RoomInfo& S_SelectRoomRes::_internal_room() const {
  const ::Protocol::RoomInfo* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_SelectRoomRes::room() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SelectRoomRes.room)
  return _internal_room();
}
inline void S_SelectRoomRes::unsafe_arena_set_allocated_room(
    ::Protocol::RoomInfo* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_SelectRoomRes.room)
}
inline ::Protocol::RoomInfo* S_SelectRoomRes::release_room() {
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::RoomInfo* S_SelectRoomRes::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:Protocol.S_SelectRoomRes.room)
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_SelectRoomRes::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::Protocol::RoomInfo* S_SelectRoomRes::mutable_room() {
  ::Protocol::RoomInfo* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SelectRoomRes.room)
  return _msg;
}
inline void S_SelectRoomRes::set_allocated_room(::Protocol::RoomInfo* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SelectRoomRes.room)
}

// string errorMessage = 3;
inline void S_SelectRoomRes::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& S_SelectRoomRes::errormessage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SelectRoomRes.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_SelectRoomRes::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_SelectRoomRes.errorMessage)
}
inline std::string* S_SelectRoomRes::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SelectRoomRes.errorMessage)
  return _s;
}
inline const std::string& S_SelectRoomRes::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void S_SelectRoomRes::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* S_SelectRoomRes::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* S_SelectRoomRes::release_errormessage() {
  // @@protoc_insertion_point(field_release:Protocol.S_SelectRoomRes.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void S_SelectRoomRes::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SelectRoomRes.errorMessage)
}

// -------------------------------------------------------------------

// C_CreateRoomReq

// string title = 1;
inline void C_CreateRoomReq::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& C_CreateRoomReq::title() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateRoomReq.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateRoomReq::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateRoomReq.title)
}
inline std::string* C_CreateRoomReq::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateRoomReq.title)
  return _s;
}
inline const std::string& C_CreateRoomReq::_internal_title() const {
  return _impl_.title_.Get();
}
inline void C_CreateRoomReq::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CreateRoomReq::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CreateRoomReq::release_title() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateRoomReq.title)
  return _impl_.title_.Release();
}
inline void C_CreateRoomReq::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateRoomReq.title)
}

// .Protocol.EGameMode mode = 2;
inline void C_CreateRoomReq::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::Protocol::EGameMode C_CreateRoomReq::_internal_mode() const {
  return static_cast< ::Protocol::EGameMode >(_impl_.mode_);
}
inline ::Protocol::EGameMode C_CreateRoomReq::mode() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateRoomReq.mode)
  return _internal_mode();
}
inline void C_CreateRoomReq::_internal_set_mode(::Protocol::EGameMode value) {
  
  _impl_.mode_ = value;
}
inline void C_CreateRoomReq::set_mode(::Protocol::EGameMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CreateRoomReq.mode)
}

// int32 maxPlayers = 3;
inline void C_CreateRoomReq::clear_maxplayers() {
  _impl_.maxplayers_ = 0;
}
inline int32_t C_CreateRoomReq::_internal_maxplayers() const {
  return _impl_.maxplayers_;
}
inline int32_t C_CreateRoomReq::maxplayers() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateRoomReq.maxPlayers)
  return _internal_maxplayers();
}
inline void C_CreateRoomReq::_internal_set_maxplayers(int32_t value) {
  
  _impl_.maxplayers_ = value;
}
inline void C_CreateRoomReq::set_maxplayers(int32_t value) {
  _internal_set_maxplayers(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CreateRoomReq.maxPlayers)
}

// string mapName = 4;
inline void C_CreateRoomReq::clear_mapname() {
  _impl_.mapname_.ClearToEmpty();
}
inline const std::string& C_CreateRoomReq::mapname() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateRoomReq.mapName)
  return _internal_mapname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateRoomReq::set_mapname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateRoomReq.mapName)
}
inline std::string* C_CreateRoomReq::mutable_mapname() {
  std::string* _s = _internal_mutable_mapname();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateRoomReq.mapName)
  return _s;
}
inline const std::string& C_CreateRoomReq::_internal_mapname() const {
  return _impl_.mapname_.Get();
}
inline void C_CreateRoomReq::_internal_set_mapname(const std::string& value) {
  
  _impl_.mapname_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CreateRoomReq::_internal_mutable_mapname() {
  
  return _impl_.mapname_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CreateRoomReq::release_mapname() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateRoomReq.mapName)
  return _impl_.mapname_.Release();
}
inline void C_CreateRoomReq::set_allocated_mapname(std::string* mapname) {
  if (mapname != nullptr) {
    
  } else {
    
  }
  _impl_.mapname_.SetAllocated(mapname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapname_.IsDefault()) {
    _impl_.mapname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateRoomReq.mapName)
}

// -------------------------------------------------------------------

// S_CreateRoomRes

// bool success = 1;
inline void S_CreateRoomRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_CreateRoomRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_CreateRoomRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateRoomRes.success)
  return _internal_success();
}
inline void S_CreateRoomRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_CreateRoomRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CreateRoomRes.success)
}

// .Protocol.RoomInfo room = 2;
inline bool S_CreateRoomRes::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool S_CreateRoomRes::has_room() const {
  return _internal_has_room();
}
inline const ::Protocol::RoomInfo& S_CreateRoomRes::_internal_room() const {
  const ::Protocol::RoomInfo* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_CreateRoomRes::room() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateRoomRes.room)
  return _internal_room();
}
inline void S_CreateRoomRes::unsafe_arena_set_allocated_room(
    ::Protocol::RoomInfo* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_CreateRoomRes.room)
}
inline ::Protocol::RoomInfo* S_CreateRoomRes::release_room() {
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::RoomInfo* S_CreateRoomRes::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:Protocol.S_CreateRoomRes.room)
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_CreateRoomRes::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::Protocol::RoomInfo* S_CreateRoomRes::mutable_room() {
  ::Protocol::RoomInfo* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CreateRoomRes.room)
  return _msg;
}
inline void S_CreateRoomRes::set_allocated_room(::Protocol::RoomInfo* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CreateRoomRes.room)
}

// string errorMessage = 3;
inline void S_CreateRoomRes::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& S_CreateRoomRes::errormessage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateRoomRes.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CreateRoomRes::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CreateRoomRes.errorMessage)
}
inline std::string* S_CreateRoomRes::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CreateRoomRes.errorMessage)
  return _s;
}
inline const std::string& S_CreateRoomRes::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void S_CreateRoomRes::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CreateRoomRes::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CreateRoomRes::release_errormessage() {
  // @@protoc_insertion_point(field_release:Protocol.S_CreateRoomRes.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void S_CreateRoomRes::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CreateRoomRes.errorMessage)
}

// -------------------------------------------------------------------

// C_JoinRoomReq

// int32 roomId = 1;
inline void C_JoinRoomReq::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C_JoinRoomReq::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C_JoinRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_JoinRoomReq.roomId)
  return _internal_roomid();
}
inline void C_JoinRoomReq::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C_JoinRoomReq::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_JoinRoomReq.roomId)
}

// -------------------------------------------------------------------

// S_JoinRoomRes

// bool success = 1;
inline void S_JoinRoomRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_JoinRoomRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_JoinRoomRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_JoinRoomRes.success)
  return _internal_success();
}
inline void S_JoinRoomRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_JoinRoomRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_JoinRoomRes.success)
}

// .Protocol.RoomInfo room = 2;
inline bool S_JoinRoomRes::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool S_JoinRoomRes::has_room() const {
  return _internal_has_room();
}
inline const ::Protocol::RoomInfo& S_JoinRoomRes::_internal_room() const {
  const ::Protocol::RoomInfo* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_JoinRoomRes::room() const {
  // @@protoc_insertion_point(field_get:Protocol.S_JoinRoomRes.room)
  return _internal_room();
}
inline void S_JoinRoomRes::unsafe_arena_set_allocated_room(
    ::Protocol::RoomInfo* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_JoinRoomRes.room)
}
inline ::Protocol::RoomInfo* S_JoinRoomRes::release_room() {
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::RoomInfo* S_JoinRoomRes::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:Protocol.S_JoinRoomRes.room)
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_JoinRoomRes::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::Protocol::RoomInfo* S_JoinRoomRes::mutable_room() {
  ::Protocol::RoomInfo* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:Protocol.S_JoinRoomRes.room)
  return _msg;
}
inline void S_JoinRoomRes::set_allocated_room(::Protocol::RoomInfo* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_JoinRoomRes.room)
}

// string errorMessage = 3;
inline void S_JoinRoomRes::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& S_JoinRoomRes::errormessage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_JoinRoomRes.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_JoinRoomRes::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_JoinRoomRes.errorMessage)
}
inline std::string* S_JoinRoomRes::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:Protocol.S_JoinRoomRes.errorMessage)
  return _s;
}
inline const std::string& S_JoinRoomRes::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void S_JoinRoomRes::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* S_JoinRoomRes::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* S_JoinRoomRes::release_errormessage() {
  // @@protoc_insertion_point(field_release:Protocol.S_JoinRoomRes.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void S_JoinRoomRes::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_JoinRoomRes.errorMessage)
}

// -------------------------------------------------------------------

// S_BroadcastJoinRoom

// .Protocol.PlayerInfo newPlayer = 1;
inline bool S_BroadcastJoinRoom::_internal_has_newplayer() const {
  return this != internal_default_instance() && _impl_.newplayer_ != nullptr;
}
inline bool S_BroadcastJoinRoom::has_newplayer() const {
  return _internal_has_newplayer();
}
inline const ::Protocol::PlayerInfo& S_BroadcastJoinRoom::_internal_newplayer() const {
  const ::Protocol::PlayerInfo* p = _impl_.newplayer_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& S_BroadcastJoinRoom::newplayer() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastJoinRoom.newPlayer)
  return _internal_newplayer();
}
inline void S_BroadcastJoinRoom::unsafe_arena_set_allocated_newplayer(
    ::Protocol::PlayerInfo* newplayer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newplayer_);
  }
  _impl_.newplayer_ = newplayer;
  if (newplayer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_BroadcastJoinRoom.newPlayer)
}
inline ::Protocol::PlayerInfo* S_BroadcastJoinRoom::release_newplayer() {
  
  ::Protocol::PlayerInfo* temp = _impl_.newplayer_;
  _impl_.newplayer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* S_BroadcastJoinRoom::unsafe_arena_release_newplayer() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastJoinRoom.newPlayer)
  
  ::Protocol::PlayerInfo* temp = _impl_.newplayer_;
  _impl_.newplayer_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* S_BroadcastJoinRoom::_internal_mutable_newplayer() {
  
  if (_impl_.newplayer_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.newplayer_ = p;
  }
  return _impl_.newplayer_;
}
inline ::Protocol::PlayerInfo* S_BroadcastJoinRoom::mutable_newplayer() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_newplayer();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastJoinRoom.newPlayer)
  return _msg;
}
inline void S_BroadcastJoinRoom::set_allocated_newplayer(::Protocol::PlayerInfo* newplayer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newplayer_);
  }
  if (newplayer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newplayer));
    if (message_arena != submessage_arena) {
      newplayer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newplayer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.newplayer_ = newplayer;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastJoinRoom.newPlayer)
}

// -------------------------------------------------------------------

// C_LeaveRoomReq

// -------------------------------------------------------------------

// S_LeaveRoomRes

// bool success = 1;
inline void S_LeaveRoomRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_LeaveRoomRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_LeaveRoomRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LeaveRoomRes.success)
  return _internal_success();
}
inline void S_LeaveRoomRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_LeaveRoomRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LeaveRoomRes.success)
}

// -------------------------------------------------------------------

// S_BroadcastLeaveRoom

// int32 playerId = 1;
inline void S_BroadcastLeaveRoom::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t S_BroadcastLeaveRoom::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t S_BroadcastLeaveRoom::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastLeaveRoom.playerId)
  return _internal_playerid();
}
inline void S_BroadcastLeaveRoom::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_BroadcastLeaveRoom::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastLeaveRoom.playerId)
}

// bool isHost = 2;
inline void S_BroadcastLeaveRoom::clear_ishost() {
  _impl_.ishost_ = false;
}
inline bool S_BroadcastLeaveRoom::_internal_ishost() const {
  return _impl_.ishost_;
}
inline bool S_BroadcastLeaveRoom::ishost() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastLeaveRoom.isHost)
  return _internal_ishost();
}
inline void S_BroadcastLeaveRoom::_internal_set_ishost(bool value) {
  
  _impl_.ishost_ = value;
}
inline void S_BroadcastLeaveRoom::set_ishost(bool value) {
  _internal_set_ishost(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastLeaveRoom.isHost)
}

// -------------------------------------------------------------------

// C_RoomChat

// string message = 1;
inline void C_RoomChat::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& C_RoomChat::message() const {
  // @@protoc_insertion_point(field_get:Protocol.C_RoomChat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_RoomChat::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_RoomChat.message)
}
inline std::string* C_RoomChat::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.C_RoomChat.message)
  return _s;
}
inline const std::string& C_RoomChat::_internal_message() const {
  return _impl_.message_.Get();
}
inline void C_RoomChat::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* C_RoomChat::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* C_RoomChat::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.C_RoomChat.message)
  return _impl_.message_.Release();
}
inline void C_RoomChat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_RoomChat.message)
}

// -------------------------------------------------------------------

// S_BroadcastRoomChat

// int32 playerId = 1;
inline void S_BroadcastRoomChat::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t S_BroadcastRoomChat::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t S_BroadcastRoomChat::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastRoomChat.playerId)
  return _internal_playerid();
}
inline void S_BroadcastRoomChat::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_BroadcastRoomChat::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastRoomChat.playerId)
}

// string playerName = 2;
inline void S_BroadcastRoomChat::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& S_BroadcastRoomChat::playername() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastRoomChat.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastRoomChat::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastRoomChat.playerName)
}
inline std::string* S_BroadcastRoomChat::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastRoomChat.playerName)
  return _s;
}
inline const std::string& S_BroadcastRoomChat::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void S_BroadcastRoomChat::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastRoomChat::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastRoomChat::release_playername() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastRoomChat.playerName)
  return _impl_.playername_.Release();
}
inline void S_BroadcastRoomChat::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastRoomChat.playerName)
}

// string message = 3;
inline void S_BroadcastRoomChat::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& S_BroadcastRoomChat::message() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastRoomChat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastRoomChat::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastRoomChat.message)
}
inline std::string* S_BroadcastRoomChat::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastRoomChat.message)
  return _s;
}
inline const std::string& S_BroadcastRoomChat::_internal_message() const {
  return _impl_.message_.Get();
}
inline void S_BroadcastRoomChat::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastRoomChat::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastRoomChat::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastRoomChat.message)
  return _impl_.message_.Release();
}
inline void S_BroadcastRoomChat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastRoomChat.message)
}

// -------------------------------------------------------------------

// C_ReadyGameReq

// bool ready = 1;
inline void C_ReadyGameReq::clear_ready() {
  _impl_.ready_ = false;
}
inline bool C_ReadyGameReq::_internal_ready() const {
  return _impl_.ready_;
}
inline bool C_ReadyGameReq::ready() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ReadyGameReq.ready)
  return _internal_ready();
}
inline void C_ReadyGameReq::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void C_ReadyGameReq::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ReadyGameReq.ready)
}

// -------------------------------------------------------------------

// S_BroadcastReadyGame

// int32 playerId = 1;
inline void S_BroadcastReadyGame::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t S_BroadcastReadyGame::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t S_BroadcastReadyGame::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastReadyGame.playerId)
  return _internal_playerid();
}
inline void S_BroadcastReadyGame::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_BroadcastReadyGame::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastReadyGame.playerId)
}

// bool ready = 2;
inline void S_BroadcastReadyGame::clear_ready() {
  _impl_.ready_ = false;
}
inline bool S_BroadcastReadyGame::_internal_ready() const {
  return _impl_.ready_;
}
inline bool S_BroadcastReadyGame::ready() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastReadyGame.ready)
  return _internal_ready();
}
inline void S_BroadcastReadyGame::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void S_BroadcastReadyGame::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastReadyGame.ready)
}

// -------------------------------------------------------------------

// C_StartGameReq

// string hostAddress = 1;
inline void C_StartGameReq::clear_hostaddress() {
  _impl_.hostaddress_.ClearToEmpty();
}
inline const std::string& C_StartGameReq::hostaddress() const {
  // @@protoc_insertion_point(field_get:Protocol.C_StartGameReq.hostAddress)
  return _internal_hostaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_StartGameReq::set_hostaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_StartGameReq.hostAddress)
}
inline std::string* C_StartGameReq::mutable_hostaddress() {
  std::string* _s = _internal_mutable_hostaddress();
  // @@protoc_insertion_point(field_mutable:Protocol.C_StartGameReq.hostAddress)
  return _s;
}
inline const std::string& C_StartGameReq::_internal_hostaddress() const {
  return _impl_.hostaddress_.Get();
}
inline void C_StartGameReq::_internal_set_hostaddress(const std::string& value) {
  
  _impl_.hostaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* C_StartGameReq::_internal_mutable_hostaddress() {
  
  return _impl_.hostaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* C_StartGameReq::release_hostaddress() {
  // @@protoc_insertion_point(field_release:Protocol.C_StartGameReq.hostAddress)
  return _impl_.hostaddress_.Release();
}
inline void C_StartGameReq::set_allocated_hostaddress(std::string* hostaddress) {
  if (hostaddress != nullptr) {
    
  } else {
    
  }
  _impl_.hostaddress_.SetAllocated(hostaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostaddress_.IsDefault()) {
    _impl_.hostaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_StartGameReq.hostAddress)
}

// int32 port = 2;
inline void C_StartGameReq::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t C_StartGameReq::_internal_port() const {
  return _impl_.port_;
}
inline int32_t C_StartGameReq::port() const {
  // @@protoc_insertion_point(field_get:Protocol.C_StartGameReq.port)
  return _internal_port();
}
inline void C_StartGameReq::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void C_StartGameReq::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Protocol.C_StartGameReq.port)
}

// -------------------------------------------------------------------

// S_StartGameRes

// bool success = 1;
inline void S_StartGameRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_StartGameRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_StartGameRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_StartGameRes.success)
  return _internal_success();
}
inline void S_StartGameRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_StartGameRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_StartGameRes.success)
}

// repeated .Protocol.PlayerInfo players = 2;
inline int S_StartGameRes::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_StartGameRes::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::PlayerInfo* S_StartGameRes::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_StartGameRes.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
S_StartGameRes::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_StartGameRes.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& S_StartGameRes::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& S_StartGameRes::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_StartGameRes.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* S_StartGameRes::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* S_StartGameRes::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_StartGameRes.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
S_StartGameRes::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_StartGameRes.players)
  return _impl_.players_;
}

// string errorMessage = 3;
inline void S_StartGameRes::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& S_StartGameRes::errormessage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_StartGameRes.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_StartGameRes::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_StartGameRes.errorMessage)
}
inline std::string* S_StartGameRes::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:Protocol.S_StartGameRes.errorMessage)
  return _s;
}
inline const std::string& S_StartGameRes::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void S_StartGameRes::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* S_StartGameRes::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* S_StartGameRes::release_errormessage() {
  // @@protoc_insertion_point(field_release:Protocol.S_StartGameRes.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void S_StartGameRes::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_StartGameRes.errorMessage)
}

// -------------------------------------------------------------------

// S_BroadcastStartGame

// string hostAddress = 1;
inline void S_BroadcastStartGame::clear_hostaddress() {
  _impl_.hostaddress_.ClearToEmpty();
}
inline const std::string& S_BroadcastStartGame::hostaddress() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastStartGame.hostAddress)
  return _internal_hostaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastStartGame::set_hostaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastStartGame.hostAddress)
}
inline std::string* S_BroadcastStartGame::mutable_hostaddress() {
  std::string* _s = _internal_mutable_hostaddress();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastStartGame.hostAddress)
  return _s;
}
inline const std::string& S_BroadcastStartGame::_internal_hostaddress() const {
  return _impl_.hostaddress_.Get();
}
inline void S_BroadcastStartGame::_internal_set_hostaddress(const std::string& value) {
  
  _impl_.hostaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastStartGame::_internal_mutable_hostaddress() {
  
  return _impl_.hostaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastStartGame::release_hostaddress() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastStartGame.hostAddress)
  return _impl_.hostaddress_.Release();
}
inline void S_BroadcastStartGame::set_allocated_hostaddress(std::string* hostaddress) {
  if (hostaddress != nullptr) {
    
  } else {
    
  }
  _impl_.hostaddress_.SetAllocated(hostaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostaddress_.IsDefault()) {
    _impl_.hostaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastStartGame.hostAddress)
}

// int32 port = 2;
inline void S_BroadcastStartGame::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t S_BroadcastStartGame::_internal_port() const {
  return _impl_.port_;
}
inline int32_t S_BroadcastStartGame::port() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastStartGame.port)
  return _internal_port();
}
inline void S_BroadcastStartGame::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void S_BroadcastStartGame::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastStartGame.port)
}

// int32 sessionId = 3;
inline void S_BroadcastStartGame::clear_sessionid() {
  _impl_.sessionid_ = 0;
}
inline int32_t S_BroadcastStartGame::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline int32_t S_BroadcastStartGame::sessionid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastStartGame.sessionId)
  return _internal_sessionid();
}
inline void S_BroadcastStartGame::_internal_set_sessionid(int32_t value) {
  
  _impl_.sessionid_ = value;
}
inline void S_BroadcastStartGame::set_sessionid(int32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastStartGame.sessionId)
}

// -------------------------------------------------------------------

// C_EndGameReq

// string reason = 1;
inline void C_EndGameReq::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& C_EndGameReq::reason() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EndGameReq.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_EndGameReq::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_EndGameReq.reason)
}
inline std::string* C_EndGameReq::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:Protocol.C_EndGameReq.reason)
  return _s;
}
inline const std::string& C_EndGameReq::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void C_EndGameReq::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* C_EndGameReq::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* C_EndGameReq::release_reason() {
  // @@protoc_insertion_point(field_release:Protocol.C_EndGameReq.reason)
  return _impl_.reason_.Release();
}
inline void C_EndGameReq::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_EndGameReq.reason)
}

// -------------------------------------------------------------------

// S_EndGameRes

// bool success = 1;
inline void S_EndGameRes::clear_success() {
  _impl_.success_ = false;
}
inline bool S_EndGameRes::_internal_success() const {
  return _impl_.success_;
}
inline bool S_EndGameRes::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EndGameRes.success)
  return _internal_success();
}
inline void S_EndGameRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_EndGameRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EndGameRes.success)
}

// -------------------------------------------------------------------

// S_BroadcastEndGame

// string reason = 1;
inline void S_BroadcastEndGame::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& S_BroadcastEndGame::reason() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastEndGame.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastEndGame::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastEndGame.reason)
}
inline std::string* S_BroadcastEndGame::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastEndGame.reason)
  return _s;
}
inline const std::string& S_BroadcastEndGame::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void S_BroadcastEndGame::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastEndGame::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastEndGame::release_reason() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastEndGame.reason)
  return _impl_.reason_.Release();
}
inline void S_BroadcastEndGame::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastEndGame.reason)
}

// int64 newHostId = 2;
inline void S_BroadcastEndGame::clear_newhostid() {
  _impl_.newhostid_ = int64_t{0};
}
inline int64_t S_BroadcastEndGame::_internal_newhostid() const {
  return _impl_.newhostid_;
}
inline int64_t S_BroadcastEndGame::newhostid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastEndGame.newHostId)
  return _internal_newhostid();
}
inline void S_BroadcastEndGame::_internal_set_newhostid(int64_t value) {
  
  _impl_.newhostid_ = value;
}
inline void S_BroadcastEndGame::set_newhostid(int64_t value) {
  _internal_set_newhostid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastEndGame.newHostId)
}

// -------------------------------------------------------------------

// S_BroadcastChangeHost

// int32 newHostPlayerId = 1;
inline void S_BroadcastChangeHost::clear_newhostplayerid() {
  _impl_.newhostplayerid_ = 0;
}
inline int32_t S_BroadcastChangeHost::_internal_newhostplayerid() const {
  return _impl_.newhostplayerid_;
}
inline int32_t S_BroadcastChangeHost::newhostplayerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastChangeHost.newHostPlayerId)
  return _internal_newhostplayerid();
}
inline void S_BroadcastChangeHost::_internal_set_newhostplayerid(int32_t value) {
  
  _impl_.newhostplayerid_ = value;
}
inline void S_BroadcastChangeHost::set_newhostplayerid(int32_t value) {
  _internal_set_newhostplayerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastChangeHost.newHostPlayerId)
}

// string playerName = 2;
inline void S_BroadcastChangeHost::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& S_BroadcastChangeHost::playername() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastChangeHost.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_BroadcastChangeHost::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastChangeHost.playerName)
}
inline std::string* S_BroadcastChangeHost::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastChangeHost.playerName)
  return _s;
}
inline const std::string& S_BroadcastChangeHost::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void S_BroadcastChangeHost::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* S_BroadcastChangeHost::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* S_BroadcastChangeHost::release_playername() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastChangeHost.playerName)
  return _impl_.playername_.Release();
}
inline void S_BroadcastChangeHost::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastChangeHost.playerName)
}

// -------------------------------------------------------------------

// S_BroadcastRoomState

// int32 roomId = 1;
inline void S_BroadcastRoomState::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t S_BroadcastRoomState::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t S_BroadcastRoomState::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastRoomState.roomId)
  return _internal_roomid();
}
inline void S_BroadcastRoomState::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void S_BroadcastRoomState::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastRoomState.roomId)
}

// .Protocol.ERoomState state = 2;
inline void S_BroadcastRoomState::clear_state() {
  _impl_.state_ = 0;
}
inline ::Protocol::ERoomState S_BroadcastRoomState::_internal_state() const {
  return static_cast< ::Protocol::ERoomState >(_impl_.state_);
}
inline ::Protocol::ERoomState S_BroadcastRoomState::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastRoomState.state)
  return _internal_state();
}
inline void S_BroadcastRoomState::_internal_set_state(::Protocol::ERoomState value) {
  
  _impl_.state_ = value;
}
inline void S_BroadcastRoomState::set_state(::Protocol::ERoomState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastRoomState.state)
}

// -------------------------------------------------------------------

// S_ErrorMessage

// string message = 1;
inline void S_ErrorMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& S_ErrorMessage::message() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ErrorMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_ErrorMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_ErrorMessage.message)
}
inline std::string* S_ErrorMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ErrorMessage.message)
  return _s;
}
inline const std::string& S_ErrorMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void S_ErrorMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* S_ErrorMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* S_ErrorMessage::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.S_ErrorMessage.message)
  return _impl_.message_.Release();
}
inline void S_ErrorMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ErrorMessage.message)
}

// -------------------------------------------------------------------

// S_KickPlayer

// string reason = 1;
inline void S_KickPlayer::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& S_KickPlayer::reason() const {
  // @@protoc_insertion_point(field_get:Protocol.S_KickPlayer.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_KickPlayer::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_KickPlayer.reason)
}
inline std::string* S_KickPlayer::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:Protocol.S_KickPlayer.reason)
  return _s;
}
inline const std::string& S_KickPlayer::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void S_KickPlayer::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* S_KickPlayer::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* S_KickPlayer::release_reason() {
  // @@protoc_insertion_point(field_release:Protocol.S_KickPlayer.reason)
  return _impl_.reason_.Release();
}
inline void S_KickPlayer::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_KickPlayer.reason)
}

// -------------------------------------------------------------------

// S_Ping

// -------------------------------------------------------------------

// C_Pong

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
